<!DOCTYPE html>
<html lang="ru">
<head>
  <meta charset="UTF-8" />
  <title>ek369</title>
  <!-- Подключаем Chart.js из CDN (для графиков) -->
  <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
  <style>
    body {
      font-family: Arial, sans-serif;
      margin: 0;
      padding: 0;
      background: #1b1b1b; /* Тёмный фон */
      color: #eaeaea; /* Светлый текст */
    }
    h1 {
      text-align: center;
      margin: 20px 0;
      color: #ffffff;
      background: #3f51b5; /* Indigo */
      padding: 10px;
    }
    #crypto-container {
      display: flex;
      flex-wrap: wrap;
      gap: 20px;
      justify-content: center;
      padding: 20px;
    }
    .crypto-card {
      background: #2b2b2b; 
      border-radius: 8px;
      box-shadow: 0 0 10px rgba(0,0,0,0.5);
      width: 640px; /* Увеличиваем под графики */
      padding: 20px;
      box-sizing: border-box;
      position: relative;
    }
    .crypto-header {
      display: flex;
      align-items: center;
      margin-bottom: 10px;
    }
    .crypto-header img {
      width: 32px;
      height: 32px;
      margin-right: 10px;
    }
    .crypto-name {
      font-size: 20px;
      font-weight: bold;
      color: #f3f3f3;
    }
    .crypto-info {
      font-size: 14px;
      margin-bottom: 10px;
    }
    .crypto-info p {
      margin: 2px 0;
    }
    .charts-container {
      display: flex;
      flex-direction: column;
      gap: 20px;
      margin-top: 10px;
    }
    .chart-block {
      background: #1f1f1f;
      padding: 10px;
      border-radius: 5px;
    }
    .chart-block canvas {
      background: #fff; /* Подложка под сам график */
      max-width: 600px;
      width: 100%;
    }
    .orderbook {
      margin-top: 10px;
      background: #1f1f1f;
      padding: 10px;
      border-radius: 5px;
    }
    .orderbook table {
      width: 100%;
      border-collapse: collapse;
    }
    .orderbook th, .orderbook td {
      text-align: left;
      padding: 4px 6px;
    }
    .orderbook th {
      background: #3f51b5;
      color: #fff;
    }
    .trade-info {
      margin-top: 10px;
      background: #1f1f1f;
      padding: 10px;
      border-radius: 4px;
      font-size: 14px;
    }
    .trade-info p {
      margin: 4px 0;
    }
    .btn-refresh {
      display: inline-block;
      background: #3f51b5;
      color: #fff;
      padding: 5px 10px;
      border-radius: 4px;
      margin-top: 10px;
      text-decoration: none;
      cursor: pointer;
      font-size: 14px;
    }
    .btn-refresh:hover {
      background: #5c6bc0;
    }

    #news-container {
      padding: 20px;
      background: #2b2b2b;
    }
    #news-container h2 {
      margin-top: 0;
    }
    .news-item {
      margin-bottom: 10px;
      padding: 10px;
      background: #1f1f1f;
      border-radius: 5px;
    }
    .news-item a {
      color: #4f9ded;
      text-decoration: none;
    }
    .news-item a:hover {
      text-decoration: underline;
    }

    #footer-upd {
      text-align: center;
      margin: 10px 0;
      font-size: 14px;
      color: #999;
    }

  </style>
</head>
<body>

<h1>ek369</h1>

<div id="crypto-container">
  <!-- Карточки монет будут генерироваться динамически -->
</div>

<div id="news-container">
  <h2>Последние новости</h2>
  <div id="news-list">
    <!-- Новости будут подгружаться сюда -->
  </div>
</div>

<div id="footer-upd"></div>

<script>
/******************************************************************************
 * Список 20 монет cоотв. CoinGecko ID + Binance Symbol (для стакана).
 * Идентификаторы и символы могут различаться, поэтому их задаём вручную.
 ******************************************************************************/
const COINS = [
  { cgId: 'bitcoin',            symbol: 'BTCUSDT' },
  { cgId: 'ethereum',           symbol: 'ETHUSDT' },
  { cgId: 'bnb',                symbol: 'BNBUSDT' },
  { cgId: 'ripple',             symbol: 'XRPUSDT' },
  { cgId: 'cardano',            symbol: 'ADAUSDT' },
  { cgId: 'solana',             symbol: 'SOLUSDT' },
  { cgId: 'dogecoin',           symbol: 'DOGEUSDT' },
  { cgId: 'polygon',            symbol: 'MATICUSDT' },
  { cgId: 'litecoin',           symbol: 'LTCUSDT' },
  { cgId: 'tron',               symbol: 'TRXUSDT' },
  { cgId: 'polkadot',           symbol: 'DOTUSDT' },
  { cgId: 'shiba-inu',          symbol: 'SHIBUSDT' },
  { cgId: 'avalanche-2',        symbol: 'AVAXUSDT' },
  { cgId: 'uniswap',            symbol: 'UNIUSDT' },
  { cgId: 'chainlink',          symbol: 'LINKUSDT' },
  { cgId: 'cosmos',             symbol: 'ATOMUSDT' },
  { cgId: 'stellar',            symbol: 'XLMUSDT' },
  { cgId: 'near',               symbol: 'NEARUSDT' },
  { cgId: 'filecoin',           symbol: 'FILUSDT' },
  { cgId: 'aptos',              symbol: 'APTUSDT' },
];

/******************************************************************************
 * Период и настройки обновления
 ******************************************************************************/
const REFRESH_INTERVAL = 30000; // мс (30 секунд)
const SMA_PERIOD = 7;          // период для одной из SMA (пример)
const RSI_PERIOD = 14;         // период для RSI
const MACD_FAST = 12;          // MACD быстрая EMA
const MACD_SLOW = 26;          // MACD медленная EMA
const MACD_SIGNAL = 9;         // MACD сигнал EMA
const BOLL_PERIOD = 20;        // Bollinger Bands период
const BOLL_STD_DEV = 2;        // стандартных отклонений

// Храним данные о позициях (виртуальные сделки) для каждой монеты:
const positions = {};
COINS.forEach(obj => {
  positions[obj.cgId] = {
    isLongOpen: false,
    entryPrice: null
  };
});

/******************************************************************************
 * Вспомогательные функции для индикаторов
 ******************************************************************************/

// Простая скользящая средняя
function sma(data, period) {
  if (data.length < period) return [];
  const result = [];
  for (let i = 0; i < data.length; i++) {
    if (i < period - 1) {
      result.push(null);
      continue;
    }
    let sum = 0;
    for (let j = i - period + 1; j <= i; j++) {
      sum += data[j];
    }
    result.push(sum / period);
  }
  return result;
}

// EMA (экспоненциальная скользящая средняя)
function ema(data, period) {
  if (data.length === 0) return [];
  const alpha = 2 / (period + 1);
  let emaArr = [data[0]];
  for (let i = 1; i < data.length; i++) {
    emaArr.push(alpha * data[i] + (1 - alpha) * emaArr[i - 1]);
  }
  // Первые элементы "сырые", но для простоты оставим
  return emaArr;
}

// RSI
function rsi(data, period = RSI_PERIOD) {
  // data — массив цен
  if (data.length < period) {
    return data.map(() => null);
  }
  const rsiValues = [];
  let gains = 0;
  let losses = 0;

  // Первичная инициализация
  for (let i = 1; i <= period; i++) {
    const diff = data[i] - data[i - 1];
    if (diff >= 0) gains += diff;
    else losses -= diff;
  }
  let avgGain = gains / period;
  let avgLoss = losses / period;
  // Первый RSI
  rsiValues[period - 1] = calcRSI(avgGain, avgLoss);

  // Идём дальше
  for (let i = period; i < data.length; i++) {
    const diff = data[i] - data[i - 1];
    let gain = 0, loss = 0;
    if (diff >= 0) gain = diff;
    else loss = -diff;

    avgGain = (avgGain * (period - 1) + gain) / period;
    avgLoss = (avgLoss * (period - 1) + loss) / period;

    rsiValues[i] = calcRSI(avgGain, avgLoss);
  }

  // Заполним пустые значения null до индекса period - 1
  for (let i = 0; i < period - 1; i++) {
    rsiValues[i] = null;
  }
  return rsiValues;

  function calcRSI(avgGain, avgLoss) {
    if (avgLoss === 0) {
      return 100; // Если нет убытков, RSI = 100
    }
    const rs = avgGain / avgLoss;
    return 100 - 100 / (1 + rs);
  }
}

// MACD (возвращает три массива: macdLine, signalLine, histogram)
function macd(data, fastPeriod = MACD_FAST, slowPeriod = MACD_SLOW, signalPeriod = MACD_SIGNAL) {
  const emaFast = ema(data, fastPeriod);
  const emaSlow = ema(data, slowPeriod);
  const macdLine = emaFast.map((val, idx) => {
    const slowVal = emaSlow[idx] !== undefined ? emaSlow[idx] : null;
    return (val && slowVal) ? val - slowVal : null;
  });
  const signalLine = ema(macdLine.filter(v => v !== null), signalPeriod);

  // signalLine короче, чем macdLine, нужно сдвинуть
  let fullSignalLine = [];
  let hist = [];
  let signalIdx = 0;
  for (let i = 0; i < macdLine.length; i++) {
    if (macdLine[i] === null) {
      fullSignalLine.push(null);
      hist.push(null);
    } else {
      const sigVal = signalLine[signalIdx];
      if (sigVal === undefined) {
        fullSignalLine.push(null);
        hist.push(null);
      } else {
        fullSignalLine.push(sigVal);
        hist.push(macdLine[i] - sigVal);
      }
      signalIdx++;
    }
  }
  return { macdLine, signalLine: fullSignalLine, histogram: hist };
}

// Bollinger Bands
function bollinger(data, period = BOLL_PERIOD, stdDevMul = BOLL_STD_DEV) {
  if (data.length < period) {
    return {
      mid: data.map(() => null),
      upper: data.map(() => null),
      lower: data.map(() => null)
    };
  }

  const mid = sma(data, period);
  const upper = [];
  const lower = [];

  for (let i = 0; i < data.length; i++) {
    if (i < period - 1) {
      upper.push(null);
      lower.push(null);
      continue;
    }
    const slice = data.slice(i - period + 1, i + 1);
    const mean = mid[i];
    let variance = 0;
    for (let p = 0; p < slice.length; p++) {
      variance += Math.pow(slice[p] - mean, 2);
    }
    variance = variance / period;
    const std = Math.sqrt(variance);
    upper.push(mean + stdDevMul * std);
    lower.push(mean - stdDevMul * std);
  }

  return { mid, upper, lower };
}

/******************************************************************************
 * Получение данных с CoinGecko (цены, sparkline), Binance (стакан) и News
 ******************************************************************************/
async function fetchCoinGeckoData() {
  try {
    const ids = COINS.map(obj => obj.cgId).join(',');
    const url = `https://api.coingecko.com/api/v3/coins/markets?vs_currency=usd&ids=${ids}&order=market_cap_desc&per_page=100&page=1&sparkline=true`;
    const resp = await fetch(url);
    const data = await resp.json();
    return data;
  } catch (err) {
    console.error('Ошибка при запросе к CoinGecko:', err);
    return [];
  }
}

// Получение биржевого стакана (первые 5 bid/ask) с Binance
async function fetchBinanceOrderBook(symbol) {
  // symbol вида BTCUSDT
  // Binance API: https://api.binance.com/api/v3/depth?symbol=BTCUSDT&limit=5
  const limit = 5;
  const url = `https://api.binance.com/api/v3/depth?symbol=${symbol}&limit=${limit}`;
  try {
    const resp = await fetch(url);
    const data = await resp.json();
    return {
      bids: data.bids || [],
      asks: data.asks || []
    };
  } catch (err) {
    console.error('Ошибка при запросе к Binance:', err);
    return { bids: [], asks: [] };
  }
}

// Получение новостей (CoinStats публичный API)
async function fetchNews() {
  // Пример эндпоинта: https://api.coinstats.app/public/v1/news?skip=0&limit=20
  // Без ключа, может поменяться в будущем.
  try {
    const url = `https://api.coinstats.app/public/v1/news?skip=0&limit=10`;
    const resp = await fetch(url);
    const json = await resp.json();
    return json.news || [];
  } catch (err) {
    console.error('Ошибка при запросе новостей:', err);
    return [];
  }
}

/******************************************************************************
 * Рисование графиков с помощью Chart.js
 ******************************************************************************/
function createChart(canvas, labels, prices, indicators) {
  // indicators содержит:
  //   sma7, rsi, macdLine, macdSignal, macdHist, bollMid, bollUp, bollLow
  const { 
    sma7, 
    rsiArr, 
    macdLine, 
    macdSignal, 
    macdHist, 
    bollMid, 
    bollUp, 
    bollLow,
    tradePoints // [{ index, price, type }]
  } = indicators;

  // Один график "главный" (цена, Bollinger, SMA), второй "подграфик" RSI, MACD
  // Но сделаем упрощённо: всё на одном canvas с несколькими y-осями.
  // yAxis 0 для цены, Bollinger, SMA; yAxis 1 для RSI (0..100); yAxis 2 для MACD.
  // Это довольно нагруженно, но продемонстрирует возможность.

  // Формируем массив точек для tradePoints, чтобы отобразить их как scatter
  const tradeLongPoints = tradePoints
    .filter(tp => tp.type === 'entry')
    .map(tp => ({ x: tp.index, y: tp.price }));
  const tradeExitPoints = tradePoints
    .filter(tp => tp.type === 'exit')
    .map(tp => ({ x: tp.index, y: tp.price }));

  const cfg = {
    type: 'line',
    data: {
      labels: labels, 
      datasets: [
        {
          label: 'Price',
          data: prices,
          borderColor: '#4caf50',
          backgroundColor: '#4caf50',
          yAxisID: 'yPrice',
          pointRadius: 0,
          borderWidth: 2
        },
        {
          label: 'SMA(' + SMA_PERIOD + ')',
          data: sma7,
          borderColor: '#ffeb3b',
          backgroundColor: '#ffeb3b',
          yAxisID: 'yPrice',
          pointRadius: 0,
          borderWidth: 1
        },
        {
          label: 'Boll Mid',
          data: bollMid,
          borderColor: '#ffffff',
          backgroundColor: '#ffffff',
          yAxisID: 'yPrice',
          pointRadius: 0,
          borderWidth: 1
        },
        {
          label: 'Boll Upper',
          data: bollUp,
          borderColor: '#e91e63',
          backgroundColor: '#e91e63',
          yAxisID: 'yPrice',
          pointRadius: 0,
          borderWidth: 1
        },
        {
          label: 'Boll Lower',
          data: bollLow,
          borderColor: '#e91e63',
          backgroundColor: '#e91e63',
          yAxisID: 'yPrice',
          pointRadius: 0,
          borderWidth: 1
        },
        {
          label: 'RSI',
          data: rsiArr,
          borderColor: '#9c27b0',
          backgroundColor: '#9c27b0',
          yAxisID: 'yRSI',
          pointRadius: 0,
          borderWidth: 2
        },
        {
          label: 'MACD',
          data: macdLine,
          borderColor: '#03a9f4',
          backgroundColor: '#03a9f4',
          yAxisID: 'yMACD',
          pointRadius: 0,
          borderWidth: 2
        },
        {
          label: 'Signal',
          data: macdSignal,
          borderColor: '#ff9800',
          backgroundColor: '#ff9800',
          yAxisID: 'yMACD',
          pointRadius: 0,
          borderWidth: 1
        },
        {
          label: 'MACD Hist',
          data: macdHist,
          type: 'bar',
          yAxisID: 'yMACD',
          backgroundColor: (ctx) => {
            let v = ctx.parsed.y;
            return v >= 0 ? 'rgba(76, 175, 80, 0.5)' : 'rgba(244, 67, 54, 0.5)';
          },
          borderWidth: 0
        },
        {
          label: 'Long Entry',
          data: tradeLongPoints,
          type: 'scatter',
          yAxisID: 'yPrice',
          pointBackgroundColor: '#00e676',
          pointRadius: 6,
        },
        {
          label: 'Long Exit',
          data: tradeExitPoints,
          type: 'scatter',
          yAxisID: 'yPrice',
          pointBackgroundColor: '#ff1744',
          pointRadius: 6,
        }
      ]
    },
    options: {
      responsive: true,
      maintainAspectRatio: false,
      scales: {
        yPrice: {
          type: 'linear',
          position: 'left',
          title: { display: true, text: 'Price' },
          grid: { color: 'rgba(255,255,255,0.1)' },
          ticks: { color: '#ccc' }
        },
        yRSI: {
          type: 'linear',
          position: 'right',
          min: 0,
          max: 100,
          title: { display: true, text: 'RSI' },
          grid: { drawOnChartArea: false, color: 'rgba(255,255,255,0.1)' },
          ticks: { color: '#ccc' }
        },
        yMACD: {
          type: 'linear',
          position: 'right',
          title: { display: true, text: 'MACD' },
          grid: { drawOnChartArea: false, color: 'rgba(255,255,255,0.1)' },
          ticks: { color: '#ccc' }
        },
        x: {
          ticks: { display: false },
          grid: { color: 'rgba(255,255,255,0.1)' }
        }
      },
      plugins: {
        legend: {
          labels: { color: '#ccc' }
        },
        tooltip: {
          mode: 'index',
          intersect: false
        }
      },
      interaction: {
        mode: 'index',
        intersect: false
      }
    }
  };

  return new Chart(canvas, cfg);
}

/******************************************************************************
 * Генерация карточек и обновление данных
 ******************************************************************************/
let chartRefs = {}; // будет хранить ссылки на Chart.js объекты, чтобы можно было перерисовывать

async function updateAllData() {
  // 1) Данные по монетам (CoinGecko)
  const cgData = await fetchCoinGeckoData();
  
  // Превратим в удобный объект по id
  const cgMap = {};
  cgData.forEach(item => {
    cgMap[item.id] = item;
  });

  // 2) Для каждой монеты — берём её данные, строим/обновляем графики, стакан и т.д.
  const container = document.getElementById('crypto-container');
  container.innerHTML = '';

  for (let i = 0; i < COINS.length; i++) {
    const coinObj = COINS[i];
    const coinId = coinObj.cgId;
    const binSymbol = coinObj.symbol;

    const info = cgMap[coinId];
    if (!info) {
      // Если вдруг нет данных, пропустим
      continue;
    }

    // 3) Достаём цены (sparkline) и рассчитываем индикаторы
    const spark = info.sparkline_in_7d?.price || [];
    // Для удобства отобразим последние N точек, например, 100 (иначе может быть > 168 точек - поминутная история за 7д)
    const maxPoints = 100;
    const startIdx = Math.max(0, spark.length - maxPoints);
    const sparkCut = spark.slice(startIdx);
    
    // Подготовка данных для индикаторов
    const sma7Arr = sma(sparkCut, SMA_PERIOD);
    const rsiArr = rsi(sparkCut, RSI_PERIOD);
    const macdObj = macd(sparkCut, MACD_FAST, MACD_SLOW, MACD_SIGNAL);
    const bollObj = bollinger(sparkCut, BOLL_PERIOD, BOLL_STD_DEV);

    // Логика «виртуальной» сделки (упрощённый пример: если цена < SMA7 на n%, открываем лонг и т.д.)
    // но мы хотим ещё на графике отметить точки входа/выхода
    // Для примера: если цена пересекает ниже BollLower - открываем лонг, выше BollUpper - выходим.
    const pos = positions[coinId];
    const tradePoints = [];
    // Пробежимся по sparkCut с конца, искать сигналы бессмысленно за весь промежуток,
    // но покажем логику, будем фиксировать, где открыли/закрыли.

    for (let idx = 1; idx < sparkCut.length; idx++) {
      const priceNow = sparkCut[idx];
      const bLow = bollObj.lower[idx];
      const bUp = bollObj.upper[idx];
      if (!bLow || !bUp) continue;

      if (!pos.isLongOpen) {
        // Проверяем вход
        if (priceNow < bLow) {
          // открываем лонг
          pos.isLongOpen = true;
          pos.entryPrice = priceNow;
          tradePoints.push({ index: idx, price: priceNow, type: 'entry' });
        }
      } else {
        // Позиция открыта, проверяем выход
        if (priceNow > bUp) {
          // Закрываем лонг
          pos.isLongOpen = false;
          tradePoints.push({ index: idx, price: priceNow, type: 'exit' });
        }
      }
    }

    // Собираем все данные для отрисовки
    const labels = sparkCut.map((_, idx) => idx.toString());
    const indicators = {
      sma7: sma7Arr,
      rsiArr: rsiArr,
      macdLine: macdObj.macdLine,
      macdSignal: macdObj.signalLine,
      macdHist: macdObj.histogram,
      bollMid: bollObj.mid,
      bollUp: bollObj.upper,
      bollLow: bollObj.lower,
      tradePoints
    };

    // 4) Создаём DOM-элементы: карточку
    const card = document.createElement('div');
    card.classList.add('crypto-card');

    // Заголовок
    const header = document.createElement('div');
    header.classList.add('crypto-header');

    const logo = document.createElement('img');
    logo.src = info.image;
    logo.alt = info.name;

    const nameEl = document.createElement('div');
    nameEl.classList.add('crypto-name');
    nameEl.textContent = `${info.name} (${info.symbol.toUpperCase()})`;

    header.appendChild(logo);
    header.appendChild(nameEl);

    // Инфа
    const cInfo = document.createElement('div');
    cInfo.classList.add('crypto-info');
    cInfo.innerHTML = `
      <p>Цена: $${info.current_price?.toLocaleString()}</p>
      <p>Капитализация: $${info.market_cap?.toLocaleString()}</p>
      <p>Изменение 24ч: ${info.price_change_percentage_24h?.toFixed(2)}%</p>
    `;

    // Блок для кнопки обновления конкретно этой монеты (необязательно, но можно)
    // const btnRefresh = document.createElement('button');
    // btnRefresh.classList.add('btn-refresh');
    // btnRefresh.textContent = 'Обновить монету';

    // Контейнер для графика
    const chartsDiv = document.createElement('div');
    chartsDiv.classList.add('charts-container');
    const chartBlock = document.createElement('div');
    chartBlock.classList.add('chart-block');
    const canvas = document.createElement('canvas');
    canvas.id = `chart_${coinId}`;
    canvas.width = 600;
    canvas.height = 300;
    chartBlock.appendChild(canvas);
    chartsDiv.appendChild(chartBlock);

    // Стакан
    const orderbookDiv = document.createElement('div');
    orderbookDiv.classList.add('orderbook');
    orderbookDiv.innerHTML = `<p>Загрузка ордербука...</p>`;

    // Инфа по сделкам (простейшая)
    const tradeInfoDiv = document.createElement('div');
    tradeInfoDiv.classList.add('trade-info');
    if (!pos.isLongOpen && !pos.entryPrice) {
      tradeInfoDiv.innerHTML = `<p>Сделка не открыта</p>`;
    } else if (pos.isLongOpen) {
      tradeInfoDiv.innerHTML = `<p>Открыт лонг по цене: $${pos.entryPrice?.toFixed(4)}</p>`;
    } else {
      tradeInfoDiv.innerHTML = `<p>Последняя сделка: вход $${pos.entryPrice?.toFixed(4)}, позиция закрыта</p>`;
    }

    card.appendChild(header);
    card.appendChild(cInfo);
    // card.appendChild(btnRefresh);
    card.appendChild(chartsDiv);
    card.appendChild(orderbookDiv);
    card.appendChild(tradeInfoDiv);

    container.appendChild(card);

    // 5) Строим/обновляем график
    // Если уже есть chartRefs[coinId], то .destroy() и заново
    if (chartRefs[coinId]) {
      chartRefs[coinId].destroy();
    }
    const ctx = canvas.getContext('2d');
    const chartInstance = createChart(ctx, labels, sparkCut, indicators);
    chartRefs[coinId] = chartInstance;

    // 6) Загружаем ордербук
    const obData = await fetchBinanceOrderBook(binSymbol);
    renderOrderBook(orderbookDiv, obData);
  }

  // 7) Обновим время внизу
  document.getElementById('footer-upd').textContent = 
    'Последнее обновление: ' + new Date().toLocaleString();
}

// Рендер ордербука
function renderOrderBook(containerEl, { bids, asks }) {
  let html = `<table>
    <tr><th>Price (Bid)</th><th>Qty</th><th>Price (Ask)</th><th>Qty</th></tr>`;
  for (let i = 0; i < Math.max(bids.length, asks.length); i++) {
    const bid = bids[i] || [];
    const ask = asks[i] || [];
    html += `<tr>
      <td>${bid[0] || ''}</td>
      <td>${bid[1] || ''}</td>
      <td>${ask[0] || ''}</td>
      <td>${ask[1] || ''}</td>
    </tr>`;
  }
  html += `</table>`;
  containerEl.innerHTML = html;
}

// Отдельная функция для обновления новостей
async function updateNews() {
  const newsData = await fetchNews();
  const newsListEl = document.getElementById('news-list');
  newsListEl.innerHTML = '';
  newsData.forEach(item => {
    const div = document.createElement('div');
    div.classList.add('news-item');
    // item: { title, link, source, feedDate, ... }
    div.innerHTML = `
      <strong>${item.title}</strong><br/>
      <small>${item.source} | ${new Date(item.feedDate * 1000).toLocaleString()}</small><br/>
      <a href="${item.link}" target="_blank">Читать подробнее</a>
    `;
    newsListEl.appendChild(div);
  });
}

// Основная инициализация
async function init() {
  await updateAllData();
  await updateNews();
}

// Запускаем сразу
init();

// Запускаем обновление каждые REFRESH_INTERVAL мс
setInterval(() => {
  updateAllData();
  updateNews();
}, REFRESH_INTERVAL);

</script>

</body>
</html>
